#include "aepch.h"
#include "EngineSound.h"
#include <EngineBase/EngineStringHelper.h>

std::map<std::string, UEngineSound*> UEngineSound::Sounds;

// 사운드를 제어하기위한 핸들
FMOD::System* SoundSystem = nullptr;

#ifdef _DEBUG
#pragma comment(lib, "fmodL_vc.lib")
#else
#pragma comment(lib, "fmod_vc.lib")
#endif

class SoundInit
{
public:
	SoundInit()
	{
		if (FMOD_RESULT::FMOD_OK != FMOD::System_Create(&SoundSystem))
		{
			MSGASSERT("FMOD 시스템 이닛에 실패했습니다.");
			return;
		}

		// 사운드 채널설정
		// int maxchannels, 동시에 몇개까지 사운드 재생이 되는가?
		// FMOD_INITFLAGS flags, 지정사항이 있냐인데
		// void* extradriverdata 지정사항에 대한 데이터넣어줄게 있냐.
		if (FMOD_RESULT::FMOD_OK != SoundSystem->init(32, FMOD_DEFAULT, nullptr))
		{
			MSGASSERT("FMOD 시스템 이닛에 실패했습니다.");
			return;
		}
	}
};

SoundInit SoundInitObject;


// 엔진이 끝날때 직접 호출
void UEngineSound::Release()
{
	std::map<std::string, UEngineSound*>::iterator StartIter = Sounds.begin();
	std::map<std::string, UEngineSound*>::iterator EndIter = Sounds.end();

	for (; StartIter != EndIter; ++StartIter)
	{
		if (nullptr != StartIter->second)
		{
			delete StartIter->second;
			StartIter->second = nullptr;
		}
	}

	Sounds.clear();
}

UEngineSound::UEngineSound()
{
}

UEngineSound::~UEngineSound()
{
}

void  UEngineSound::Load(std::string_view _Path)
{
	UEnginePath EnginePath = UEnginePath(_Path);
	std::string FileName = EnginePath.GetPathName();

	UEngineSound::Load(FileName.data(), _Path);
}

void UEngineSound::Load(std::string_view _Name, std::string_view _Path)
{
	// 이녀석은 UTF-8로 경로를 바꿔주야 한다.
	std::string UpperString = UEngineStringHelper::ToUpper(_Path);

	UEngineSound* NewSound = new UEngineSound();


	if (false == NewSound->ResLoad(_Path))
	{
		delete NewSound;
		MSGASSERT("사운드 로드에 실패했습니다" + UpperString);
		return;
	}
	;

	UEngineSound::Sounds.insert({ UpperString, NewSound });
	// Load(FileName, Path);
}


bool UEngineSound::ResLoad(std::string_view _Path)
{
	// FMOD를 사용하는 부분
	int a = 0;

	return true;
}